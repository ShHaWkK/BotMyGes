"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGoogleAccessToken = exports.pushToCalendar = exports.removeEvents = exports.readEvents = void 0;
const googleapis_1 = require("googleapis");
const date_fns_1 = require("date-fns");
const cli_progress_1 = __importDefault(require("cli-progress"));
const colors_1 = __importDefault(require("colors"));
const campus_location_1 = require("./campus-location");
const inquirer_1 = __importDefault(require("inquirer"));
const multiBar = new cli_progress_1.default.MultiBar({
    format: ' {task} |' + colors_1.default.blue('{bar}') + '| {percentage}% || {value}/{total}',
    barCompleteChar: '\u2588',
    barIncompleteChar: '\u2591',
    hideCursor: true,
});
let eventAdded = true;
let eventRemoved = true;
const taskComplete = () => {
    if (eventAdded && eventRemoved) {
        multiBar.stop();
    }
};
function readEvents(startTime, endTime, calendarId, config) {
    const googleClient = getClient(config.google_api_credentials, config.google_api_token);
    retrieveEvents(googleClient, calendarId, startTime, endTime, displayEvents);
}
exports.readEvents = readEvents;
function removeEvents(startTime, endTime, calendarId, config) {
    const googleClient = getClient(config.google_api_credentials, config.google_api_token);
    retrieveEvents(googleClient, calendarId, startTime, endTime, deleteEvents);
}
exports.removeEvents = removeEvents;
function pushToCalendar(events, calendarId, config) {
    const googleClient = getClient(config.google_api_credentials, config.google_api_token);
    const googleEvents = events.map((event) => createEvent(event));
    addEvents(googleClient, calendarId, googleEvents);
}
exports.pushToCalendar = pushToCalendar;
function retrieveEvents(auth, calendarId, startTime, endTime, callback) {
    const calendar = googleapis_1.google.calendar({
        version: 'v3',
        auth,
        http2: true,
    });
    calendar.events.list({
        calendarId,
        timeMin: startTime.toISOString(),
        timeMax: endTime.toISOString(),
        singleEvents: true,
        orderBy: 'startTime',
    }, (err, res) => callback(err, res, calendar, calendarId));
}
function addEvents(auth, calendarId, events) {
    const calendar = googleapis_1.google.calendar({
        version: 'v3',
        auth,
        http2: true,
    });
    eventAdded = false;
    const progressBar = multiBar.create(events.length, 0, {
        task: 'Adding new events  ',
    });
    const tasks = events.map((event, i) => setTimeout(() => new Promise((resolve, reject) => {
        calendar.events.insert({
            calendarId,
            requestBody: event,
        }, { http2: true }, (err, res) => {
            progressBar.increment();
            if (err) {
                console.error(err);
                reject(err);
            }
            else {
                resolve(res);
            }
        });
    }), 500 * (i + 1)));
    Promise.all(tasks).finally(() => {
        eventAdded = true;
        taskComplete();
    });
}
function displayEvents(err, res) {
    if (err)
        return console.log('The API returned an error: ' + err);
    const events = res.data.items;
    if (events.length) {
        events.forEach((event) => {
            const start = event.start.dateTime || event.start.date;
            const end = event.end.dateTime || event.end.date;
            console.log(`${start}->${end} - ${event.summary}`);
        });
    }
    else {
        console.log('No upcoming events found.');
    }
}
function deleteEvents(errP, resP, calendar, calendarId) {
    if (errP)
        return console.error('The API returned an error: ' + errP);
    const events = resP.data.items;
    if (events.length) {
        eventRemoved = false;
        const progressBar = multiBar.create(events.length, 0, {
            task: 'Removing old events',
        });
        const tasks = events.map((event, i) => new Promise((resolve, reject) => {
            setTimeout(() => {
                calendar.events.delete({
                    calendarId,
                    eventId: event.id,
                }, { http2: true }, (err, res) => {
                    progressBar.increment();
                    if (err) {
                        console.error(err);
                        reject(err);
                    }
                    else {
                        resolve(res);
                    }
                });
            }, 500 * (i + 1));
        }));
        Promise.all(tasks).finally(() => {
            eventRemoved = true;
            taskComplete();
        });
    }
    else {
        console.log('No events to delete found.');
    }
}
function getEventDescription(agendaItem) {
    let description = '';
    if (agendaItem.teacher && agendaItem.teacher.length > 0) {
        description += `<span>Intervenant : ${agendaItem.teacher} </span><br>`;
    }
    if (agendaItem.rooms && agendaItem.rooms.length > 0) {
        description += `<span>Salle(s) :<ul>${agendaItem.rooms
            .map((room) => `<li>${room.campus} - ${room.name}</li>`)
            .join('')}</ul></span>`;
    }
    return description;
}
function getEventColorId(agendaItem) {
    if (!agendaItem.rooms || agendaItem.rooms.length == 0) {
        return '11';
    }
    return (0, campus_location_1.getCampusLocation)(agendaItem.rooms[0].campus)[1];
}
function getEventLocation(agendaItem) {
    if (!agendaItem.rooms || agendaItem.rooms.length === 0) {
        return undefined;
    }
    return (0, campus_location_1.getCampusLocation)(agendaItem.rooms[0].campus)[0];
}
function createEvent(agendaItem) {
    return {
        summary: agendaItem.name,
        description: getEventDescription(agendaItem),
        colorId: getEventColorId(agendaItem),
        location: getEventLocation(agendaItem),
        start: {
            dateTime: (0, date_fns_1.formatRFC3339)(new Date(agendaItem.start_date)),
            timeZone: 'Europe/Paris',
        },
        end: {
            dateTime: (0, date_fns_1.formatRFC3339)(new Date(agendaItem.end_date)),
            timeZone: 'Europe/Paris',
        },
    };
}
function getClient(credentials, token) {
    const { client_secret, client_id } = credentials.installed;
    const oAuth2Client = new googleapis_1.google.auth.OAuth2(client_id, client_secret, 'urn:ietf:wg:oauth:2.0:oob');
    oAuth2Client.setCredentials(token);
    return oAuth2Client;
}
async function promptGoogleAccessToken(authUrl, oAuth2Client) {
    const { token_code } = await inquirer_1.default.prompt([
        {
            message: "Authorize this app by visiting this url and retrieving authorization code : \n'" +
                authUrl +
                "'\nPast authorization code -> ",
            name: 'token_code',
        },
    ]);
    try {
        const { tokens } = await oAuth2Client.getToken(token_code);
        if (!tokens) {
            throw new Error('An error has occurred when retrieving Google API authorization code');
        }
        return tokens;
    }
    catch (e) {
        console.error(e.message);
        return promptGoogleAccessToken(authUrl, oAuth2Client);
    }
}
async function getGoogleAccessToken(credentials) {
    const SCOPES = ['https://www.googleapis.com/auth/calendar'];
    const { client_secret, client_id } = credentials.installed;
    const oAuth2Client = new googleapis_1.google.auth.OAuth2(client_id, client_secret, 'urn:ietf:wg:oauth:2.0:oob');
    const authUrl = oAuth2Client.generateAuthUrl({
        access_type: 'offline',
        scope: SCOPES,
    });
    try {
        return await promptGoogleAccessToken(authUrl, oAuth2Client);
    }
    catch (e) {
        throw new Error(`Prompt couldn't be rendered in the current environment: ${e}`);
    }
}
exports.getGoogleAccessToken = getGoogleAccessToken;
